## А что делать если хочу расширить метод дочернего класса, при этом оставив функциональность родительского метода?

# В этом случае используется специальная функция `super`.
# `super()` — это встроенная функция в Python, которая позволяет обращаться к методам родительского класса.
# Основное предназначение `super()` заключается в том, чтобы обеспечить возможность вызова методов родительского класса в подклассе.
# Это особенно полезно в ситуациях, когда нужно расширить или переопределить поведение родительского класса в дочернем классе,
# сохранив при этом часть функциональности родительского класса.

# **Пример использования super()**:
# Рассмотрим пример с классами `Animal` и `Dog`.
# Допустим, Animal имеет метод `__init__`, который устанавливает общий атрибут для всех животных.
# В классе `Dog` мы можем использовать `super()`, чтобы вызвать `__init__`
# родительского класса и дополнить его дополнительными действиями.

class Animal:
    def __init__(self, name):
        self.name = name
        print(f"{self.name} is an animal.")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Вызов конструктора родительского класса
        self.breed = breed
        print(f"{self.name} is a {self.breed} dog.")

dog = Dog("Buddy", "Golden Retriever")

# В этом примере `super().__init__(name)` вызывает конструктор родительского класса `Animal`,
# который выполняет свою часть работы (устанавливает имя животного).
# Затем дочерний класс `Dog` выполняет свою дополнительную работу (устанавливает породу собаки).
# `super()` просто позволяет получить или вызвать что-то из родительского класса.
# Чаще всего его можно встретить в конструкторе `__init__`,
# но это может быть и любые другие методы и атрибуты.
# При этом место вызова особо роли не играет, так как вызов функции просто выполняет действия из родительского класса.

class A:
    def __init__(self, param_a):
        self.param_a = param_a

    def get_param(self):
        return self.param_a

    def print_value(self, value):
        print(value)

class B(A):

    def __init__(self, param_a, param_b):
        super().__init__(param_a)  # Здесь я хочу, чтобы вызвался родительский __init__ и создались теже
        # атрибуты, что и у родителя
        self.param_b = param_b  # Создаётся свой атрибут специфичный для этого класса

    def get_param(self):
        """Расширяем метод get_param, возвращает тоже
        что возвращал self.param_a, но с улучшениями
        """
        print("Вот это моё улучшение")
        # Таким образом возвращается то, что вернется после вызова родительского метода.
        # Важно что все данные в метод для super() подставятся из класса B, а не из A
        return super().get_param()

    def print_value(self, value):
        super().print_value(value)  # Вызывается родительский метод
        print("Новый функционал")


if __name__ == "__main__":
    b = B(10, 20)
    print(b.get_param())
    b.print_value(30)